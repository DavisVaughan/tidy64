% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidy64.R
\name{new_tidy64}
\alias{new_tidy64}
\alias{new_tidy64_subclass}
\title{Construct a new tidy64}
\usage{
new_tidy64(left = double(), right = double(), ..., class = character())

new_tidy64_subclass(x = new_tidy64(), ..., names = NULL, class = character())
}
\arguments{
\item{left}{\verb{[double]}

A vector of integerish double values in the range of
\verb{[-2147483648, 2147483647]}. These represent the left most 32 bits
of the \code{int64_t} extracted by:
\itemize{
\item Mapping the \code{int64_t} to \code{uint64_t}.
\item Right shifting with \verb{x_u64 >> 32} to get the left 32 bits as a
\code{uint32_t}.
\item Mapping the unsigned left 32 bits of \code{x_u64} to a signed \code{int32_t}. This
maintains ordering automatically in operations like \code{vec_order()}.
\item Coercing the resulting \code{int32_t} to a double.
}}

\item{right}{\verb{[double]}

A vector of integerish double values in the range of
\verb{[0, 4294967295]}. These represent the right most 32 bits
of the \code{int64_t} extracted by:
\itemize{
\item Mapping the \code{int64_t} to \code{uint64_t}.
\item Directly coercing the resulting \code{x_u64} to \code{uint32_t}, which gives us
the right 32 bits as a \code{uint32_t}.
\item Coercing the resulting \code{uint32_t} to a double.
}}

\item{...}{\verb{[named dots]}

Name value pairs resulting in extra attributes attached to the new tidy64.}

\item{class}{\verb{[character]}

A vector of subclasses.}

\item{x}{\verb{[tidy64]}

An existing tidy64 to create the subclass from.}

\item{names}{\verb{[NULL / character]}

Names to attach to the new tidy64 subclass. Either \code{NULL} for no names,
or a character vector of names the same size as \code{x}.}
}
\description{
\emph{For expert use only!}

\code{new_tidy64()} is a bare bones constructor for
creating tidy64 objects from their 32 bit components. You should almost
always use \code{\link[=tidy64]{tidy64()}} or \code{\link[=as_tidy64]{as_tidy64()}} instead.

\code{new_tidy64_subclass()} is a slightly more developer friendly way to create
a subclass of tidy64. It takes an existing tidy64, breaks it apart, and
then uses \code{new_tidy64()} to form a new tidy64 with the subclass and
attributes attached.
}
\examples{
new_tidy64()
new_tidy64(0, 1)
new_tidy64(0, 2)
new_tidy64(1, 0)

new_tidy64_subclass(tidy64(1), names = "x", class = "foobar")
}
